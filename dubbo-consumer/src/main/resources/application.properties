server.port=8012

#dubbo消费者的应用名称、注册中心地址、协议名称、协议端口、
dubbo.application.name=user-service-consumer
dubbo.registry.address=47.94.155.21:2181,47.94.155.21:2182,47.94.155.21:2183
dubbo.registry.protocol=zookeeper

#暂时关闭掉监控中心，如需要得先开启监控中心服务
#dubbo.monitor.protocol=registry

# 打开(关闭)所有服务的启动时检查（没有提供者时会报错）默认就是打开
dubbo.consumer.check=true
# 打开(关闭)注册中心启动时检查(注册订阅失败时报错) 默认就是打开
dubbo.registry.check=true

# 设置消费者超时时间为3s  默认值为1000ms
# 在consumer中设置是全局的
dubbo.consumer.timeout=3000

# 以timeout为例 显示了配置的查找顺序 其他retries,loadbalance,actives等类似
   # 方法级优先 接口级次之 全局配置再次之
   # 如果级别一样 则消费方优先 提供方次之
   # 其中，服务提供方配置，通过URl经由注册中心传递给消费方
# 超时时间总结：方法级别的超时时间优先 且消费者优于提供者  然后是接口级别  最后是dubbo-consumer全局优于dubbo-provider全局
# 消费方 reference（消费者引用）优先 提供者 dubbo service interface（暴露服务）次之

# 有这样一种场景 如果在提供者的方法级别设置超时时间为1000ms  在消费者的接口级别设置超时时间为5000ms
#       此时肯定是提供者的超时时间优先 因为 级别不一样  所以方法级优先！
     # 这就是超时时间配置的覆盖关系 大概有这几种情况 要记住！  精确优先！  消费者优先！

# 重试次数，不包含第一次调用；比如说第一次调用失败了，还会再调用三次
# 举个例子 比如在提供方方法超时时间为1000ms，消费方5000ms，此时会调用失败 那么就在提供者方法中打印一行日志 则会打印4次，打印后消费者才会抛错

# 还有一个重试的场景就是
#   启动三个服务提供方 消费方掉服务提供方 重试三次会到三个提供方上
#   最后呈现为服务提供方一2次打印  服务提供方二1次打印 服务提供方三1次打印

# 幂等方法上（设置重试次数【查询、删除、修改】）、非幂等（不能设置重试次数【新增】）因为新增因为超时可能数据库已经添加了
# 0就代表不可重试~
dubbo.consumer.retries=3